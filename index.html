<!DOCTYPE html>
<html>
<style type='text/css'>
  canvas {
    border: 1px solid magenta;
  }
</style>
<body></body>
<script type='text/javascript'>

// a polynomial of form (where 'c' = this.coefficients)
// c[0] + c[1]x + c[2]x^2 + c[3]x^3... etc
class Polynomial {
  constructor(coefficients) {
    this.coefficients = coefficients;
  }

  valueAt(x) {
    let result = 0;
    for (let i = 0; i < this.coefficients.length; i++) {
      const c = this.coefficients[i];
      result += c * (x ** i);
    }
    return result;
  }

  derivative() {
    const coefficients = [];
    for (let i = 1; i < this.coefficients.length; i++) {
      const c = this.coefficients[i];
      coefficients.push(c * i);
    }
    return new Polynomial(coefficients);
  }
}

class ComplexNumber {
  constructor(real, imaginary) {
    this.real = real;
    this.imaginary = imaginary;
  }

  multiply(A) {
    const result = this.copy();
    if (A instanceof ComplexNumber) {
      result.real = A.real * this.real - A.imaginary * this.imaginary;
      result.imaginary = A.real * this.imaginary + A.imaginary * this.real;
    } else if (typeof(A) === "number") {
      result.real *= A;
      result.imaginary *= A;
    } else {
      throw new Error("Must multiply with either a number or a complex number");
    }
    return result;
  }

  divide(A) {
    const result = this.copy();
    if (typeof(A) === "number") {
      result.real /= A;
      result.imaginary /= A;
    } else if (A instanceof ComplexNumber) {
      const a = this.real;
      const b = this.imaginary;
      const c = A.real;
      const d = A.imaginary;
      result.real = (a*c + b*d) / (c**2 + d**2);
      result.imaginary = (b*c + a*d) /(c**2 + d**2);
    } else {
      throw new Error("Must divide with either a number or a complex number");
    }
    return result;
  }

  add(A) {
    const result = this.copy();
    if (A instanceof ComplexNumber) {
      result.real += A.real;
      result.imaginary += A.imaginary;
    } else if (typeof(A) === "number") {
      result.real += A;
    } else {
      throw new Error("Must add with either a number or a complex number")
    }
    return result;
  }

  power(n) {
    if (n === 0)
      return new ComplexNumber(1, 0);
    let result = this.copy();
    for (let i = 0; i < n - 1; i++) {
      result = result.multiply(this);
    }
    return result;
  }

  lengthSq() {
    return this.real ** 2 + this.imaginary ** 2;
  }

  copy() {
    return new ComplexNumber(this.real, this.imaginary);
  }
}

function multiplyComplex(numbers) {
  const result = numbers[0].copy();
  for (var i = 1; i < numbers.length; i++)
    result.multiply(numbers[i]);
  return result;
}

function addComplex(numbers) {
  const result = numbers[0].copy();
  for (var i = 1; i < numbers.length; i++)
    result.add(numbers[i]);
  return result;
}

class ComplexPolynomial {
  constructor(roots) {
    this.roots = roots;
    this.coefficients = null;
    this.derivative = null;
  }

  valueAt(x) {
    if (!(x instanceof ComplexNumber))
      x = new ComplexNumber(x, 0);
    if (!this.coefficients)
      expand();
    let result = new ComplexNumber(0, 0);
    for (let i = 0; i < this.coefficients.length; i++) {
      const component = this.coefficients[i].multiply(x.power(i));
      result = result.add(component);
    }
    return result;
  }

  derivativeAt(x) {
    if (!(x instanceof ComplexNumber))
      x = new ComplexNumber(x, 0);
    if (!this.derivative)
      this.getDerivative();
    let result = new ComplexNumber(0, 0);
    for (let i = 0; i < this.derivative.length; i++) {
      const component = this.derivative[i].multiply(x.power(i));
      result = result.add(component);
    }
    return result;
  }

  getDerivative() {
    if (this.derivative)
      return;

    if (!this.coefficients)
      this.expand();

    this.derivative = [];
    this.derivative[0] = this.coefficients[1];
    this.derivative[1] = this.coefficients[2].multiply(2);
    this.derivative[2] = this.coefficients[3].multiply(3);
  }

  // Just go with order of 3 for now
  expand() {
    if (this.roots.length > 3)
      throw new Error("Can only expand polynomials of degree 3 or less")

    this.coefficients = [];

    // for shorthand
    const a = this.roots[0] ? this.roots[0] : new ComplexNumber(0, 0);
    const b = this.roots[1] ? this.roots[1] : new ComplexNumber(0, 0);
    const c = this.roots[2] ? this.roots[2] : new ComplexNumber(0, 0);

    // this.coefficients[0] = multiplyComplex([a, b, c]).multiply(-1);
    this.coefficients[0] = a.multiply(b).multiply(c).multiply(-1);
    this.coefficients[1] = a.multiply(b).add(a.multiply(c)).add(b.multiply(c));
    this.coefficients[2] = a.add(b).add(c).multiply(-1);
    this.coefficients[3] = new ComplexNumber(1, 0);
  }
}

function newtonStep(polynomial, guess) {
  const px = polynomial.valueAt(guess);
  const pprimex = polynomial.derivative().valueAt(guess);
  return guess - (px/pprimex);
}

// returns a zero and the number of steps it took to get there
function findZero(polynomial, guess, tolerance) {
  let value = polynomial.valueAt(guess);
  let num_steps = 0;
  while (value > tolerance || value < -1*tolerance) {
    const new_guess = newtonStep(polynomial, guess);
    guess = new_guess;
    num_steps += 1;
    value = polynomial.valueAt(guess);
  }

  return [guess, num_steps];
}

function complexNewtonStep(polynomial, guess) {
  const px = polynomial.valueAt(guess);
  const pprimex = polynomial.derivativeAt(guess);
  return guess.add(px.divide(pprimex).multiply(-1));
}

function complexFindZero(polynomial, guess, tolerance) {
  let value = polynomial.valueAt(guess);
  let num_steps = 0;
  while (value.lengthSq() > tolerance) {
    const new_guess = complexNewtonStep(polynomial, guess);
    guess = new_guess;
    num_steps += 1;
    if (num_steps > 100)
      break;
      // throw new Error("Too many steps");
    value = polynomial.valueAt(guess);
  }

  return [guess, num_steps];
}

const ROOTS = [
  new ComplexNumber(0, 0),
  new ComplexNumber(10, 0),
  new ComplexNumber(5, 7),
];
const func = new ComplexPolynomial(ROOTS);
func.expand();
// func.derivativeAt(new ComplexNumber(-1, 0));
const zero = complexFindZero(func, new ComplexNumber(5, 7), 0.1);
// console.log(zero[0].real.toFixed(0), zero[0].imaginary.toFixed(0), zero[1]);

const POINT_SIZE = 5;
const PIXEL_SIZE = 10;
const S = 500;
const canvas = document.createElement('canvas');
canvas.width = canvas.height = S;
document.body.appendChild(canvas);
const ctx = canvas.getContext('2d');
ctx.moveTo(0, S/2);
ctx.lineTo(S, S/2);
ctx.moveTo(S/2, 0);
ctx.lineTo(S/2, S);
ctx.stroke();

ctx.beginPath();


const COLORS = ["red", "blue", "green"];
function findClosestZero(value) {
  let minDist = 10000;
  let minRoot = null;
  for (i in ROOTS) {
    const r = ROOTS[i];
    const dist = (r.real - value.real) ** 2 + (r.imaginary - value.imaginary) ** 2;
    if (dist < minDist) {
      minDist = dist;
      minRoot = i;
    }
  }
  // console.log(minRoot);
  return minRoot;
}

ctx.translate(S/2, S/2);
const dim = S/PIXEL_SIZE;
// const zero1 = complexFindZero(func, new ComplexNumber(5, 0), .10)[0];
// console.log(zero1.real, zero1.imaginary);
for (var x = -dim/2; x < dim/2; x+=0.5) {
  for (var y = -dim/2; y < dim/2; y+=0.5) {
    const zero = complexFindZero(func, new ComplexNumber(x, y), .10)[0];
    // console.log(x, y, zero.real, zero.imaginary);
    const numRoot = findClosestZero(zero);
    // console.log(numRoot);
    ctx.beginPath();
    ctx.fillStyle = COLORS[numRoot];
    // console.log(COLORS[numRoot]);
    ctx.arc(PIXEL_SIZE * x, PIXEL_SIZE * y, 3, 0, 2*Math.PI);
    ctx.fill();
  }
}

ctx.fillStyle = "black";
for (r of ROOTS) {
  ctx.beginPath();
  ctx.arc(PIXEL_SIZE * r.real, PIXEL_SIZE * r.imaginary, POINT_SIZE, 0, 2*Math.PI);
  ctx.fill();
}

</script>
</html>
